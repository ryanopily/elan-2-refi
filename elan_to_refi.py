# -*- coding: utf-8 -*-
"""ELAN_to_REFI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    [redacted]
"""

from xml.etree import ElementTree
import uuid
import os

from annotate import annotate

transcript_file = None
elan_file = None

def convert(elan, transcript):

    global transcript_file, elan_file
    
    transcript_file = transcript
    elan_file = elan

    #read in original .eaf file as an xml tree
    elan_tree = ElementTree.parse(elan)
    elan_root = elan_tree.getroot()
    
    refi_root = ElementTree.Element('Project')
    parse_annotation_doc(elan_root,refi_root,'DocName')
    
    time_order = elan_root.find('TIME_ORDER')
    times = parse_time_slots(time_order)
    
    controlled_vocab = parse_controlled_vocab(elan_root)
    transfer_codes(refi_root,controlled_vocab)
    
    uuid_dict = create_uuids(elan_root)
    
    parse_annotations(elan_root,refi_root,times,uuid_dict)
    for elem in refi_root.iter():
      if elem == None:
        refi_root.remove(elem)
        
    #save new refi tree as .qde file
    return ElementTree.ElementTree(refi_root)
    #refi_tree.write(output_file,encoding='utf-8',xml_declaration=True)

#transfer attributes from ELAN 'ANNOTATION_DOCUMENT' to REFI 'Project' element
def parse_annotation_doc(elan_node,refi_node,name):
  date = elan_node.attrib['DATE']
  refi_node.set('modifiedDateTime',date)
  
  #specify the project name and the refi xml schema
  refi_node.set('name',name)
  refi_node.set('xmlns','urn:QDA-XML:project:1.0')
  refi_node.set('xmlns:xsi','http://www.w3.org/2001/XMLSchema-instance')
  refi_node.set('xsi:schemaLocation','urn:QDA-XML:project:1.0 http://schema.qdasoftware.org/versions/Project/v1.0/Project.xsd')

  author = elan_node.attrib['AUTHOR']
  
  print("AUTHOR ", author) 
  if author == "":
    print("AUTHOR UNKNOWN")
    author = "Elan2Refi"
  
  Users = ElementTree.Element('Users')
  refi_node.append(Users)
  
  User = ElementTree.Element('User',{'name':author,'guid':str(uuid.uuid4())})
  Users.append(User)

#create dictionary of time codes for annotations from ELAN
def parse_time_slots(elan_time_order):
  times = {}
  for elem in elan_time_order:
    id = elem.attrib['TIME_SLOT_ID']
    val = elem.attrib['TIME_VALUE']
    times[id]=val
  return times

#create a dictionary of ELAN controlled vocab
def parse_controlled_vocab(elan_root):
  cv = {}
  for elem in elan_root.findall('CONTROLLED_VOCABULARY'):
    for subelem in elem.findall('CV_ENTRY_ML'):
      id = subelem.attrib['CVE_ID']
      val = subelem.find('CVE_VALUE').text
      cv[id]=val
  return cv

#based on dictionary, transfer ELAN controlled vocab to REFI codes
def transfer_codes(refi_root,vocab):
  Codebook = ElementTree.Element('CodeBook')
  refi_root.append(Codebook)
  Codes = ElementTree.Element('Codes')
  Codebook.append(Codes)

  for code in vocab.keys():
    elem = ElementTree.Element('Code',{'guid':code[6:],'name':vocab[code],'isCodable':'true'})
    Codes.append(elem)

#assign every ELAN annotation a uuid, store in dictionary
def create_uuids(elan_root):
  id_uuid = {}
  for annot in elan_root.iter('ALIGNABLE_ANNOTATION'):
    id = annot.attrib['ANNOTATION_ID']
    id_uuid[id] = str(uuid.uuid4())
  for annot in elan_root.iter('REF_ANNOTATION'):
    id = annot.attrib['ANNOTATION_ID']
    id_uuid[id] = str(uuid.uuid4())

  return id_uuid

#transfer alignable annotations on video source to REFI 'selections'
def parse_annotations(elan_root,refi_root,time_dict,uuid_dict):
  Sources = ElementTree.Element('Sources')
  refi_root.append(Sources)

  #find ELAN relative file path
  header = elan_root.find('HEADER')
  source = header.find('MEDIA_DESCRIPTOR')

  source_path = source.attrib['RELATIVE_MEDIA_URL']
  source_path = 'internal://'+source_path[2:]

  #Save this source in REFI format
  VideoSource = ElementTree.Element('VideoSource',{'guid':str(uuid.uuid4()),'path':source_path})
  Sources.append(VideoSource)

  #Link the transcript to the REFI file
  trans_path = 'internal://'+os.path.basename(transcript_file)
  Transcript = annotate(elan_file,transcript_file)
  Transcript.set('path', trans_path)
  #Transcript = ElementTree.Element('Transcript',{'guid':str(uuid.uuid4()),'path':trans_path})
  VideoSource.append(Transcript)
  
  #transfer alignable annotations
  for annot in elan_root.iter('ALIGNABLE_ANNOTATION'):
    id = annot.attrib['ANNOTATION_ID']
    guid = uuid_dict[id]
    begin = time_dict[annot.attrib['TIME_SLOT_REF1']]
    end = time_dict[annot.attrib['TIME_SLOT_REF2']]
    val = annot.find('ANNOTATION_VALUE').text
    if val == None:
      val = ''
   
    #store these attributes in refi format
    ref_elem = ElementTree.Element('VideoSelection',{'guid':guid,'begin':begin,'end':end,'name':val})
    VideoSource.append(ref_elem)

    #if annotation has cv reference, add code as child of selection
    if 'CVE_REF' in annot.attrib.keys():
      cv = annot.attrib['CVE_REF']
      Coding = ElementTree.Element('Coding',{'guid':str(uuid.uuid4())})
      ref_elem.append(Coding)
      CodeRef = ElementTree.Element('CodeRef',{'targetGUID':cv[6:]})
      Coding.append(CodeRef)

  #transfer ref annotations
  for annot in elan_root.iter('REF_ANNOTATION'):
    id = annot.attrib['ANNOTATION_ID']
    guid = uuid_dict[id]
    val = annot.find('ANNOTATION_VALUE').text
    if val == None:
      val = ''
    cv = annot.attrib.get('CVE_REF','')
    
    #retrieve parent time stamp before adding new selection
    parent_id = annot.attrib['ANNOTATION_REF']
    for nodes in refi_root.findall('VideoSelection'):
      if node.attrib['guid']==id:
        begin = node.attrib['begin']
        end = node.attrib['end']
        break

    #store these attributes in refi format
    ref_elem = ElementTree.Element('VideoSelection',{'guid':guid,'begin':begin,'end':end,'name':val})
    VideoSource.append(ref_elem)

    #if annotation has cv reference, add code as child of selection
    Coding = ElementTree.Element('Coding',{'guid':str(uuid.uuid4())})
    ref_elem.append(Coding)
    CodeRef = ElementTree.Element('CodeRef',{'targetGUID':cv[6:]})
    Coding.append(CodeRef)